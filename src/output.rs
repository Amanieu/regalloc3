//! Output of register allocation.
//!
//! This is represented by the [`Output`] type and primarily consists of two
//! parts: allocations and moves.
//!
//! # Allocations
//!
//! For each instruction, the allocator will produce an array of
//! [`Allocation`]s, one per [`Operand`]. An allocation can represent either a
//! [`SpillSlot`] or a [`PhysReg`]. Registers and spillslot are assigned
//! according to the constraints on the operand, and will faithfully preserve
//! the dataflow of the input program.
//!
//! In the case of register group operands, only the first register of the group
//! is returned in the allocation list.
//!
//! # Moves
//!
//! In order to implement the necessary movement of data between allocations,
//! the allocator needs to insert moves at various points between the original
//! program instructions.
//!
//! These moves may consist of reg-to-reg, reg-to-stack (spill) and stack-to-reg
//! (fill) moves. Since most ISAs lack instructions for stack-to-stack moves,
//! the register allocation will automatically split those using a scratch
//! register in [`RegInfo::stack_to_stack_class`].
//!
//! # Rematerialization
//!
//! If a [`Value`] has been marked as being rematerializable then the allocator
//! may insert an [`OutputInst::Rematerialize`] between two instructions which
//! indicates that the given value should be rematerialized into the given
//! [`Allocation`]. This is often cheaper than spilling to the stack, especially
//! for constant values.
//!
//! [`Operand`]: super::function::Operand

use core::fmt;

use cranelift_entity::packed_option::ReservedValue;
use cranelift_entity::{EntityRef as _, Keys, PrimaryMap};

use crate::function::{Block, Function, Inst, InstRange, Value};
use crate::internal::move_resolver::Edit;
use crate::reginfo::{PhysReg, RegInfo, SpillSlotSize};
use crate::RegisterAllocator;

/// Maximum size of the spill area.
pub const MAX_SPILL_AREA_SIZE: u32 = 1 << 29;

/// Space in the stackframe used by the allocator to temporarily store a value.
///
/// The allocator is responsible for allocating slots in this space, and will
/// specify the total size of the spill area when the allocation is completed.
/// Spillslots generated by the allocator are guaranteed to never overlap.
///
/// Note that this is distinct from a fixed stack slot (e.g. argument or return
/// value stack slot) which is instead represented using a `PhysReg`.
#[derive(Copy, Clone, Eq, PartialEq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SpillSlot(u32);
entity_impl!(SpillSlot(u32), "spill");

/// Expanded form of `Allocation` as an enum.
///
/// This allows `Allocation` itself to be efficiently bit-packed in 32 bits.
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum AllocationKind {
    /// Allocatetd in a physical register or fixed stack slot.
    PhysReg(PhysReg),

    /// Allocated in a spill slot on the stack.
    SpillSlot(SpillSlot),
}

/// An `Allocation` represents the end result of regalloc for an `Operand`.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Allocation {
    /// Bit-pack in 32 bits.
    ///
    /// kind:1 index:31
    /// kind:1 unused:19 reg:12
    bits: u32,
}

impl fmt::Debug for Allocation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(self, f)
    }
}

impl fmt::Display for Allocation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self.kind() {
            AllocationKind::PhysReg(reg) => write!(f, "{reg}"),
            AllocationKind::SpillSlot(spillslot) => write!(f, "{spillslot}"),
        }
    }
}

impl Allocation {
    /// Constructs a new `Allocation`.
    #[inline]
    #[must_use]
    pub fn new(kind: AllocationKind) -> Self {
        let bits = match kind {
            AllocationKind::SpillSlot(spillslot) => spillslot.index() as u32,
            AllocationKind::PhysReg(reg) => 1 << 31 | reg.index() as u32,
        };
        Self { bits }
    }

    /// Creates an allocation into a `PhysReg`.
    #[inline]
    #[must_use]
    pub fn reg(reg: PhysReg) -> Allocation {
        Allocation::new(AllocationKind::PhysReg(reg))
    }

    /// Creates an allocation into a `SpillSlot`.
    #[inline]
    #[must_use]
    pub fn spillslot(spillslot: SpillSlot) -> Allocation {
        Allocation::new(AllocationKind::SpillSlot(spillslot))
    }

    /// Expands the `AllocationKind` into an enum that can be matched on.
    #[inline]
    #[must_use]
    pub fn kind(self) -> AllocationKind {
        match self.bits >> 31 {
            0 => AllocationKind::SpillSlot(SpillSlot::new(self.bits as usize)),
            1 => AllocationKind::PhysReg(PhysReg::new(self.bits as usize & !(1 << 31))),
            _ => unreachable!(),
        }
    }

    /// Returns whethere this allocation represents a memory location rather
    /// than a register.
    ///
    /// This returns true if the allocation is a [`PhysReg`] that represents a
    /// memory location such as a fixed stack slot.
    #[inline]
    pub fn is_memory(self, reginfo: &impl RegInfo) -> bool {
        match self.kind() {
            AllocationKind::PhysReg(reg) => reginfo.is_memory(reg),
            AllocationKind::SpillSlot(_) => true,
        }
    }
}

impl ReservedValue for Allocation {
    #[inline]
    fn reserved_value() -> Self {
        // This encodes an invalid `PhysReg`.
        Self { bits: !0 }
    }

    #[inline]
    fn is_reserved_value(&self) -> bool {
        self.bits == !0
    }
}

/// The output of the register allocator.
pub struct Output<'a, F, R> {
    pub(crate) regalloc: &'a RegisterAllocator,
    pub(crate) func: &'a F,
    pub(crate) reginfo: &'a R,
}

impl<'a, F, R> Output<'a, F, R>
where
    F: Function,
    R: RegInfo,
{
    /// Returns the input [`Function`] to the register allocator.
    #[inline]
    #[must_use]
    pub fn function(&self) -> &F {
        self.func
    }

    /// Returns the input [`RegInfo`] to the register allocator.
    #[inline]
    #[must_use]
    pub fn reginfo(&self) -> &R {
        self.reginfo
    }

    /// Returns an iterator over the output instructions in the given block.
    ///
    /// This consists of original program instructions as well as moves and
    /// rematerializations inserted by the register allocator.
    #[inline]
    #[must_use]
    pub fn output_insts(&self, block: Block) -> OutputIter<'a> {
        let insts = self.func.block_insts(block);
        let edits = self.regalloc.move_resolver.edits_from(insts.from);
        OutputIter {
            insts,
            edits,
            regalloc: self.regalloc,
        }
    }

    /// Returns the layout of the stack frame containing all spill slots.
    #[inline]
    #[must_use]
    pub fn stack_layout(&self) -> &StackLayout {
        &self.regalloc.spill_allocator.stack_layout
    }

    /// Returns the [`Allocation`]s assigned to each [`Value`] at different
    /// points in the function.
    ///
    /// Specifically, this indicates where values are located when they are
    /// *live through* an instruction. This means that the value was defined in
    /// a previous instruction and this is not the last use of this value.
    /// Notably, this information may not be accurate between instruction since
    /// values can be moved around.
    ///
    /// Also note that this information is not accurate in following cases:
    /// - `Reuse` definitions appear to be live in instruction that defines
    ///   them, unlike other `Def`s.
    /// - These locations are not valid for "jump" terminators (terminators of
    ///   blocks with one successor where that successor has multiple
    ///   predecessors).
    /// - These ranges are guaranteed to be non-overlapping, but may not be
    ///   complete in places where the value is dead or if it is later
    ///   rematerialized.
    #[inline]
    pub fn value_locations(&self) -> impl Iterator<Item = (Value, InstRange, Allocation)> + 'a {
        // Gather segments from assigned registers and spill slots and return
        // the allocation assigned to each.
        self.regalloc
            .allocator
            .assignments()
            .flat_map(|(vreg, reg)| {
                self.regalloc.virt_regs[vreg]
                    .segments(&self.regalloc.virt_regs)
                    .iter()
                    .filter_map(move |segment| {
                        let inst_range = InstRange::new(
                            segment.live_range.from.round_to_next_inst().inst(),
                            segment.live_range.to.round_to_prev_inst().inst(),
                        );
                        if !inst_range.is_empty() {
                            Some((segment.value, inst_range, Allocation::reg(reg)))
                        } else {
                            None
                        }
                    })
            })
            .chain(
                self.regalloc
                    .spill_allocator
                    .spilled_segments()
                    .map(|(spillslot, segment)| {
                        let inst_range = InstRange::new(
                            segment.live_range.from.round_to_next_inst().inst(),
                            segment.live_range.to.round_to_prev_inst().inst(),
                        );
                        (segment.value, inst_range, Allocation::spillslot(spillslot))
                    }),
            )
    }
}

/// Positions of all the spill slots in the stack frame.
pub struct StackLayout {
    /// Size and offset of each spill slot.
    pub(crate) slots: PrimaryMap<SpillSlot, (u32, SpillSlotSize)>,

    /// Total size of the spill area.
    pub(crate) spillslot_area_size: u32,
}

impl StackLayout {
    /// Returns an iterator over all allocated spill slots.
    #[inline]
    #[must_use]
    pub fn spillslots(&self) -> Keys<SpillSlot> {
        self.slots.keys()
    }

    /// Returns the offset of a spill slot in the spill area.
    #[inline]
    #[must_use]
    pub fn spillslot_offset(&self, slot: SpillSlot) -> u32 {
        self.slots[slot].0
    }

    /// Returns the size of a spill slot.
    #[inline]
    #[must_use]
    pub fn spillslot_size(&self, slot: SpillSlot) -> SpillSlotSize {
        self.slots[slot].1
    }

    /// Returns the amount of space on the stack needed for all allocated
    /// spill slots.
    ///
    /// Each spill slot used by the allocator encodes an offset from the start
    /// of this spill area.
    #[inline]
    #[must_use]
    pub fn spillslot_area_size(&self) -> u32 {
        self.spillslot_area_size
    }
}

/// Iterator over the [`OutputInst`] of a block after register allocation.
pub struct OutputIter<'a> {
    insts: InstRange,
    edits: &'a [(Inst, Edit)],
    regalloc: &'a RegisterAllocator,
}

impl<'a> Iterator for OutputIter<'a> {
    type Item = OutputInst<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.insts.is_empty() {
            None
        } else {
            // Any edits happen before the corresponding instruction.
            if let Some((&(pos, edit), rest)) = self.edits.split_first() {
                if pos <= self.insts.from {
                    debug_assert_eq!(pos, self.insts.from);
                    self.edits = rest;
                    return Some(match edit.from.expand() {
                        Some(from) => OutputInst::Move {
                            from,
                            to: edit.to,
                            value: edit.value.expand(),
                        },
                        None => OutputInst::Rematerialize {
                            to: edit.to,
                            value: edit.value.expect("remat without value"),
                        },
                    });
                }
            }

            let inst = self.insts.from;
            self.insts.from = self.insts.from.next();
            Some(OutputInst::Inst {
                inst,
                operand_allocs: self.regalloc.allocations.inst_allocations(inst),
                stack_map: self.regalloc.allocations.inst_stack_map(inst),
            })
        }
    }
}

/// Wrapper around either an original instruction or an inserted move.
#[derive(Copy, Clone, Debug)]
pub enum OutputInst<'a> {
    /// An original instruction, with its operands mapped to `Allocation`s.
    ///
    /// Note that due to rematerialization, not all instructions of the original
    /// function may be present. This can happen if the original instruction had
    /// no side effects and its outputs are not needed.
    Inst {
        /// The reference to the original instruction.
        inst: Inst,

        /// The `Allocation` for each `Operand` of the instruction.
        ///
        /// In the case of register group operands, only the allocation for the
        /// first group member is recorded here.
        operand_allocs: &'a [Allocation],

        /// If this instruction is a safepoint, this contains the locations of
        /// all ref-type values that are live at this program point.
        stack_map: &'a [Allocation],
    },

    /// A value which should be re-materialized into the given `Allocation`.
    ///
    /// There are strict restrictions on rematerializable values: they cannot
    /// depend on any other allocatable register and they are only allowed to
    /// use a single destination register as scratch space.
    Rematerialize {
        /// Value being rematerialized.
        value: Value,

        /// Destination into which the rematerialized value should be wrriten.
        to: Allocation,
    },

    /// A move instruction inserted by the register allocator.
    ///
    /// `value` indicates the original SSA value currently contained in the
    /// `from` allocation.
    Move {
        /// Source location of the move.
        from: Allocation,

        /// Destination location of the move.
        to: Allocation,

        /// SSA value that is being copied. In the case of block parameter
        /// moves, this is the *source* value in the predecessor block.
        ///
        /// This is `None` when a register is being temporarily evicted to a
        /// spill slot or restored from such a spill slot.
        value: Option<Value>,
    },
}
